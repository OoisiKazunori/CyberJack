#include"DebugScene.h"
#include"../Camera/CameraMgr.h"
#include"../Input/KeyBoradInputManager.h"
#include"../Math/KazMath.h"
#include"../Helper/KazHelper.h"
#include"../Helper/KazBufferHelper.h"
#include"../KazLibrary/Pipeline/GraphicsPipeLineMgr.h"
#include"../KazLibrary/DirectXCommon/DirectX12CmdList.h"
#include"../KazLibrary/Buffer/DescriptorHeapMgr.h"
#include"../KazLibrary/Loader/TextureResourceMgr.h"
#include"../KazLibrary/Helper/ResourceFilePass.h"
#include"../KazLibrary/RenderTarget/RenderTargetStatus.h"
#include"../Imgui/MyImgui.h"

DebugScene::DebugScene()
{
	//short texHandle = TextureResourceMgr::Instance()->LoadGraph(KazFilePathName::TestPath + "");
	uavHandle = 0;
	srvHandle = 0;
	buffer = std::make_unique<CreateGpuBuffer>();
	//繧ｳ繝槭Φ繝峨す繧ｰ繝阪メ繝｣縺ｮ逕滓・---------------------------
	std::array<D3D12_INDIRECT_ARGUMENT_DESC, 2> args{};
	args[0].Type = D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT_BUFFER_VIEW;//DrawIndexedInstanced蜻ｽ莉､繧定､・焚蜻ｼ縺ｳ蜃ｺ縺・
	args[0].ConstantBufferView.RootParameterIndex = 0;
	args[1].Type = D3D12_INDIRECT_ARGUMENT_TYPE_DRAW;

	//繧ｳ繝槭Φ繝峨す繧ｰ繝阪メ繝｣縺ｮ險ｭ螳・------------------------
	D3D12_COMMAND_SIGNATURE_DESC desc{};
	desc.pArgumentDescs = args.data();
	desc.NumArgumentDescs = static_cast<UINT>(args.size());
	desc.ByteStride = sizeof(IndirectCommand); //繧ｵ繝ｳ繝励Ν縺縺ｨ荳縺､縺縺後√％縺捺悽譚･謠冗判蛻・し繧､繧ｺ繧堤畑諢上＠縺ｪ縺・→縺・￠縺ｪ縺・ｰ励′縺吶ｋ縺ｮ縺縺・..
	//繧ｳ繝槭Φ繝峨す繧ｰ繝阪メ繝｣縺ｮ險ｭ螳・------------------------

	auto result = DirectX12Device::Instance()->dev->CreateCommandSignature(&desc, GraphicsRootSignature::Instance()->GetRootSignature(ROOTSIGNATURE_DATA_DRAW).Get(), IID_PPV_ARGS(&commandSig));
	//繧ｳ繝槭Φ繝峨す繧ｰ繝阪メ繝｣縺ｮ逕滓・---------------------------


	//螳壽焚繝舌ャ繝輔ぃ縺ｮ逕滓・---------------------------
	const UINT constantBufferDataSize = TRIANGLE_RESOURCE_COUNT * sizeof(SceneConstantBuffer);
	paramCBHandle = buffer->CreateBuffer(KazBufferHelper::SetConstBufferData(constantBufferDataSize));
	{

		//遘ｻ蜍暮㍼縺ｮ蛻晄悄蛹・
		for (UINT n = 0; n < TRIANGLE_ARRAY_NUM; n++)
		{
			constantBufferData[n].velocity = XMFLOAT4(KazMath::FloatRand(0.01f, 0.02f), 0.0f, 0.0f, 0.0f);
			constantBufferData[n].offset = XMFLOAT4(KazMath::FloatRand(-5.0f, -1.5f), KazMath::FloatRand(-1.0f, 1.0f), KazMath::FloatRand(0.0f, 2.0f), 0.0f);
			constantBufferData[n].color = XMFLOAT4(KazMath::FloatRand(1.0f, 0.0f), KazMath::FloatRand(0.0f, 1.0f), KazMath::FloatRand(0.0f, 1.0f), 1.0f);

			float m_aspectRatio = static_cast<float>(WIN_X) / static_cast<float>(WIN_Y);
			XMStoreFloat4x4(&constantBufferData[n].projection, XMMatrixTranspose(XMMatrixPerspectiveFovLH(XM_PIDIV4, m_aspectRatio, 0.01f, 20.0f)));
		}

		pointer = buffer->GetMapAddres(paramCBHandle);
		memcpy(pointer, &constantBufferData[0], TRIANGLE_ARRAY_NUM * sizeof(SceneConstantBuffer));

		//螳壽焚繝舌ャ繝輔ぃ縺ｮ繝薙Η繝ｼ縺ｯ菴懊ｋ
		cbvSize = DescriptorHeapMgr::Instance()->GetSize(DESCRIPTORHEAP_MEMORY_CBV);

		D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
		srvDesc.Format = DXGI_FORMAT_UNKNOWN;
		srvDesc.ViewDimension = D3D12_SRV_DIMENSION_BUFFER;
		srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
		srvDesc.Buffer.NumElements = TRIANGLE_ARRAY_NUM;
		srvDesc.Buffer.StructureByteStride = sizeof(SceneConstantBuffer);
		srvDesc.Buffer.Flags = D3D12_BUFFER_SRV_FLAG_NONE;
		cbvHandle = 0;
		for (UINT frame = 0; frame < FRAME_COUNT; frame++)
		{
			srvDesc.Buffer.FirstElement = frame * TRIANGLE_ARRAY_NUM;
			DescriptorHeapMgr::Instance()->CreateBufferView(cbvSize.startSize + frame, srvDesc, buffer->GetBufferData(paramCBHandle).Get());
			++cbvHandle;
		}
	}
	//螳壽焚繝舌ャ繝輔ぃ縺ｮ逕滓・---------------------------


	//鬆らせ繝舌ャ繝輔ぃ髢｢騾｣-------------------------
	{
		const float TriangleHalfWidth = 0.08f;
		const float TriangleDepth = 0.0f;
		const float CullingCutoff = 0.5f;
		struct Vert
		{
			XMFLOAT3 pos;
		};
		std::array<Vert, 3>vert;
		vert[0].pos = { 0.0f, 0.5f, TriangleDepth };
		vert[1].pos = { 0.5f, 0.0f, TriangleDepth };
		vert[2].pos = { -0.5f, 0.0f, TriangleDepth };

		int size = static_cast<int>(vert.size()) * sizeof(Vert);
		short handle = buffer->CreateBuffer(KazBufferHelper::SetVertexBufferData(size));
		buffer->TransData(handle, vert.data(), size);

		vertexBufferView = KazBufferHelper::SetVertexBufferView(buffer->GetGpuAddress(handle), size, sizeof(vert[0]));
	}
	//鬆らせ繝舌ャ繝輔ぃ髢｢騾｣-------------------------


	//繧ｳ繝槭Φ繝峨ヰ繝・ヵ繧｡逕滓・-------------------------
	{
		std::array<IndirectCommand, TRIANGLE_RESOURCE_COUNT> commands;
		const UINT commandBufferSize = CommandSizePerFrame * FRAME_COUNT;
		commandBufferHandle = buffer->CreateBuffer(KazBufferHelper::SetCommandBufferData(commandBufferSize));
		short uplod = buffer->CreateBuffer(KazBufferHelper::SetStructureBuffer(commandBufferSize));

		D3D12_GPU_VIRTUAL_ADDRESS gpuAddress = buffer->GetGpuAddress(paramCBHandle);//螳壽焚繝舌ャ繝輔ぃ縺ｮ逕滓・縺後＞繧・
		UINT commandIndex = 0;
		for (UINT frame = 0; frame < FRAME_COUNT; frame++)
		{
			for (UINT n = 0; n < TRIANGLE_ARRAY_NUM; n++)
			{
				commands[commandIndex].cbv = gpuAddress;
				commands[commandIndex].drawArguments.VertexCountPerInstance = 3;
				commands[commandIndex].drawArguments.InstanceCount = 1;
				commands[commandIndex].drawArguments.StartVertexLocation = 0;
				commands[commandIndex].drawArguments.StartInstanceLocation = 0;

				commandIndex++;
				gpuAddress += sizeof(SceneConstantBuffer);
			}
		}
		//繧ｳ繝槭Φ繝峨ヰ繝・ヵ繧｡逕滓・-------------------------

		D3D12_SUBRESOURCE_DATA commandData = {};
		commandData.pData = reinterpret_cast<UINT8 *>(&commands[0]);
		commandData.RowPitch = commandBufferSize;
		commandData.SlicePitch = commandData.RowPitch;
		UpdateSubresources<1>(DirectX12CmdList::Instance()->cmdList.Get(), buffer->GetBufferData(commandBufferHandle).Get(), buffer->GetBufferData(uplod).Get(), 0, 0, 1, &commandData);


		//繧ｳ繝槭Φ繝峨ヰ繝・ヵ繧｡縺ｮSRV逕ｨ諢・------------------------
		D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
		srvDesc.Format = DXGI_FORMAT_UNKNOWN;
		srvDesc.ViewDimension = D3D12_SRV_DIMENSION_BUFFER;
		srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
		srvDesc.Buffer.NumElements = TRIANGLE_ARRAY_NUM;
		srvDesc.Buffer.StructureByteStride = sizeof(IndirectCommand);
		srvDesc.Buffer.Flags = D3D12_BUFFER_SRV_FLAG_NONE;

		for (int i = 0; i < FRAME_COUNT; ++i)
		{
			srvDesc.Buffer.FirstElement = i * TRIANGLE_ARRAY_NUM;

			//螳壽焚繝舌ャ繝輔ぃ縺ｮ繝薙Η繝ｼ縺ｯ菴懊ｋ
			BufferMemorySize s = DescriptorHeapMgr::Instance()->GetSize(DESCRIPTORHEAP_MEMORY_SRV);
			DescriptorHeapMgr::Instance()->CreateBufferView(s.startSize + i, srvDesc, buffer->GetBufferData(commandBufferHandle).Get());
			++srvHandle;
		}
		//繧ｳ繝槭Φ繝峨ヰ繝・ヵ繧｡縺ｮSRV逕ｨ諢・------------------------


#pragma region ComputeShader


		//蜈･蜉帷畑繝舌ャ繝輔ぃ縺ｮ逕滓・-------------------------
		{
			inputHandle = buffer->CreateBuffer(KazBufferHelper::SetStructureBuffer(TRIANGLE_ARRAY_NUM * sizeof(InputData), "InputParam"));

			std::array<InputData, TRIANGLE_ARRAY_NUM> data;
			for (int i = 0; i < TRIANGLE_ARRAY_NUM; ++i)
			{
				data[i].pos = { 11.0f,10.0f,10.0f,0.0f };
				data[i].velocity = { 0.0f,0.0f,0.0f,0.0f };
				data[i].color = { KazMath::FloatRand(1.0f,0.0f),KazMath::FloatRand(1.0f,0.0f),KazMath::FloatRand(1.0f,0.0f),1.0f };
			}
			XMVECTOR pos = { data[0].pos.x,data[0].pos.y,data[0].pos.z,0.0f };
			XMVECTOR scale = { 15.0f,15.0f,15.0f,0.0f };
			XMVECTOR rota = { 0.0f,0.0f,0.0f,0.0f };
			XMMATRIX matWorld = {};
			XMMATRIX matWorld2 = {};

			//陦悟・險育ｮ励・豁｣隗｣
			{
				XMMATRIX trans = KazMath::CaluTransMatrix(pos);
				XMMATRIX trans2 = Translate(KazMath::LoadVecotrToXMFLOAT3(pos));
				XMMATRIX scaleM = KazMath::CaluScaleMatrix(scale);
				XMMATRIX scaleM2 = Scale(KazMath::LoadVecotrToXMFLOAT3(scale));
				XMMATRIX rotaM = KazMath::CaluRotaMatrix(rota);
				XMMATRIX rotaM2 = Rotate(KazMath::LoadVecotrToXMFLOAT3(rota));
				matWorld = scaleM * rotaM * trans;
				matWorld2 = scaleM2 * rotaM2 * trans2;

				bool dbeug = false;
			}

			//繧ｷ繧ｧ繝ｼ繝繝ｼ蛛ｴ縺ｧ險育ｮ励＠繧医≧縺ｨ縺励※縺・ｋ陦悟・險育ｮ・
			{
			}

			buffer->TransData(inputHandle, data.data(), TRIANGLE_ARRAY_NUM * sizeof(InputData));

			D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
			srvDesc.Format = DXGI_FORMAT_UNKNOWN;
			srvDesc.ViewDimension = D3D12_SRV_DIMENSION_BUFFER;
			srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
			srvDesc.Buffer.NumElements = TRIANGLE_ARRAY_NUM;
			srvDesc.Buffer.StructureByteStride = sizeof(InputData);
			srvDesc.Buffer.Flags = D3D12_BUFFER_SRV_FLAG_NONE;
			BufferMemorySize s = DescriptorHeapMgr::Instance()->GetSize(DESCRIPTORHEAP_MEMORY_SRV);
			DescriptorHeapMgr::Instance()->CreateBufferView(s.startSize + srvHandle, srvDesc, buffer->GetBufferData(inputHandle).Get());
			++srvHandle;
		}
		//蜈･蜉帷畑繝舌ャ繝輔ぃ縺ｮ逕滓・-------------------------


		size = DescriptorHeapMgr::Instance()->GetSize(DESCRIPTORHEAP_MEMORY_TEXTURE_COMPUTEBUFFER);

		int uavHandle = 1;
		//蜃ｺ蜉帷畑縺ｮ繝舌ャ繝輔ぃ縺ｮ逕滓・---------------------------
		//陦悟・邉ｻ
		{
			outputMatHandle = buffer->CreateBuffer(KazBufferHelper::SetRWStructuredBuffer(TRIANGLE_ARRAY_NUM * sizeof(OutPutData)));



			D3D12_UNORDERED_ACCESS_VIEW_DESC uavDesc = {};
			uavDesc.Format = DXGI_FORMAT_UNKNOWN;
			uavDesc.ViewDimension = D3D12_UAV_DIMENSION_BUFFER;
			uavDesc.Buffer.FirstElement = 0;
			uavDesc.Buffer.NumElements = TRIANGLE_ARRAY_NUM;
			uavDesc.Buffer.StructureByteStride = sizeof(OutPutData);
			uavDesc.Buffer.CounterOffsetInBytes = 0;
			uavDesc.Buffer.Flags = D3D12_BUFFER_UAV_FLAG_NONE;

			DescriptorHeapMgr::Instance()->CreateBufferView(size.startSize + uavHandle, uavDesc, buffer->GetBufferData(outputMatHandle).Get(), nullptr);
		}
		++uavHandle;


		//遘ｻ蜍暮㍼譖ｴ譁ｰ
		{
			updateInputHandle = buffer->CreateBuffer(KazBufferHelper::SetRWStructuredBuffer(TRIANGLE_ARRAY_NUM * sizeof(InputData)));

			D3D12_UNORDERED_ACCESS_VIEW_DESC uavDesc = {};
			uavDesc.Format = DXGI_FORMAT_UNKNOWN;
			uavDesc.ViewDimension = D3D12_UAV_DIMENSION_BUFFER;
			uavDesc.Buffer.FirstElement = 0;
			uavDesc.Buffer.NumElements = TRIANGLE_ARRAY_NUM;
			uavDesc.Buffer.StructureByteStride = sizeof(InputData);
			uavDesc.Buffer.CounterOffsetInBytes = 0;
			uavDesc.Buffer.Flags = D3D12_BUFFER_UAV_FLAG_NONE;

			DescriptorHeapMgr::Instance()->CreateBufferView(size.startSize + uavHandle, uavDesc, buffer->GetBufferData(updateInputHandle).Get(), nullptr);
		}
		++uavHandle;

		commonHandle = buffer->CreateBuffer(KazBufferHelper::SetConstBufferData(sizeof(CommonData) * TRIANGLE_ARRAY_NUM, "CommonData"));
		{
			D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
			srvDesc.Format = DXGI_FORMAT_UNKNOWN;
			srvDesc.ViewDimension = D3D12_SRV_DIMENSION_BUFFER;
			srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
			srvDesc.Buffer.NumElements = TRIANGLE_ARRAY_NUM;
			srvDesc.Buffer.StructureByteStride = sizeof(CommonData);
			srvDesc.Buffer.Flags = D3D12_BUFFER_SRV_FLAG_NONE;

			//DescriptorHeapMgr::Instance()->CreateBufferView(cbvSize.startSize + cbvHandle, srvDesc, buffer->GetBufferData(commonHandle).Get());
			++cbvHandle;
		}


		{
			cbvMatHandle = buffer->CreateBuffer(KazBufferHelper::SetConstBufferData(TRIANGLE_ARRAY_NUM * sizeof(OutPutData), "CbvMatHandle"));

			D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
			srvDesc.Format = DXGI_FORMAT_UNKNOWN;
			srvDesc.ViewDimension = D3D12_SRV_DIMENSION_BUFFER;
			srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
			srvDesc.Buffer.NumElements = TRIANGLE_ARRAY_NUM;
			srvDesc.Buffer.StructureByteStride = sizeof(OutPutData);
			srvDesc.Buffer.Flags = D3D12_BUFFER_SRV_FLAG_NONE;
			DescriptorHeapMgr::Instance()->CreateBufferView(cbvSize.startSize + cbvHandle, srvDesc, buffer->GetBufferData(cbvMatHandle).Get());
			++cbvHandle;
		}

		//DrawIndirect
		{
			drawCommandHandle = buffer->CreateBuffer(KazBufferHelper::SetRWStructuredBuffer(TRIANGLE_ARRAY_NUM * sizeof(IndirectCommand)));

			std::array<IndirectCommand, TRIANGLE_ARRAY_NUM> lCommands;
			D3D12_GPU_VIRTUAL_ADDRESS cbGpuAddress = buffer->GetGpuAddress(cbvMatHandle);//螳壽焚繝舌ャ繝輔ぃ縺ｮ逕滓・縺後＞繧・
			for (int i = 0; i < lCommands.size(); ++i)
			{
				lCommands[i].cbv = cbGpuAddress + i * sizeof(IndirectCommand);
				lCommands[i].drawArguments.VertexCountPerInstance = 3;
				lCommands[i].drawArguments.InstanceCount = 1;
				lCommands[i].drawArguments.StartVertexLocation = 0;
				lCommands[i].drawArguments.StartInstanceLocation = 0;
			}
			buffer->TransData(drawCommandHandle, &lCommands, TRIANGLE_ARRAY_NUM * sizeof(IndirectCommand));


			D3D12_UNORDERED_ACCESS_VIEW_DESC uavDesc = {};
			uavDesc.Format = DXGI_FORMAT_UNKNOWN;
			uavDesc.ViewDimension = D3D12_UAV_DIMENSION_BUFFER;
			uavDesc.Buffer.FirstElement = 0;
			uavDesc.Buffer.NumElements = TRIANGLE_ARRAY_NUM;
			uavDesc.Buffer.StructureByteStride = sizeof(IndirectCommand);
			uavDesc.Buffer.CounterOffsetInBytes = 0;
			uavDesc.Buffer.Flags = D3D12_BUFFER_UAV_FLAG_NONE;
			DescriptorHeapMgr::Instance()->CreateBufferView(size.startSize + uavHandle, uavDesc, buffer->GetBufferData(drawCommandHandle).Get(), nullptr);
			++uavHandle;

		}
		//蜃ｺ蜉帷畑縺ｮ繝舌ャ繝輔ぃ縺ｮ逕滓・---------------------------

		//繝ｪ繧ｻ繝・ヨ逕ｨ縺ｮ繝舌ャ繝輔ぃ-------------------------

		//繝ｪ繧ｻ繝・ヨ逕ｨ縺ｮ繝舌ャ繝輔ぃ-------------------------
#pragma endregion

>>>>>>> dev_GPUParticle_DebugRenderDoc


	}
}

DebugScene::~DebugScene()
{
}

void DebugScene::Init()
{
}

void DebugScene::Finalize()
{
}

void DebugScene::Update()
{
	CameraMgr::Instance()->Camera(eyePos, targetPos, { 0.0f,1.0f,0.0f });

	//コンピュート用のパイプライン設定
	GraphicsPipeLineMgr::Instance()->SetComputePipeLineAndRootSignature(PIPELINE_COMPUTE_NAME_TEST);

	//入力用のデータ転送
	buffer->TransData(inputHandle, &inputData, sizeof(InputData));

	//入力用のバッファ設定
	DirectX12CmdList::Instance()->cmdList->SetComputeRootDescriptorTable(0, DescriptorHeapMgr::Instance()->GetGpuDescriptorView(size.startSize));
	//出力用のバッファ設定
	DirectX12CmdList::Instance()->cmdList->SetComputeRootDescriptorTable(1, DescriptorHeapMgr::Instance()->GetGpuDescriptorView(size.startSize + 1));

	//共通データのバッファ設定と転送
	{
		XMVECTOR pos = { 11.0f,10.0f,10.0f,0.0f };
		XMVECTOR scale = { 15.0f,15.0f,15.0f,0.0f };
		XMVECTOR rota = { 0.0f,0.0f,0.0f,0.0f };

		XMMATRIX matWorld;
		XMMATRIX trans = Translate(KazMath::LoadVecotrToXMFLOAT3(pos));
		XMMATRIX scaleM = Scale(KazMath::LoadVecotrToXMFLOAT3(scale));
		XMMATRIX rotaM = Rotate(KazMath::LoadVecotrToXMFLOAT3(rota));
		matWorld = scaleM * rotaM * trans;

		XMMATRIX v = CameraMgr::Instance()->GetViewMatrix();
		XMMATRIX p = CameraMgr::Instance()->GetPerspectiveMatProjection();
		XMMATRIX mat = matWorld * v;
		mat = mat * p;
	}


	for (UINT n = 0; n < TRIANGLE_ARRAY_NUM; n++)
	{
		const float offsetBounds = 2.5f;

		// Animate the triangles
		constantBufferData[n].offset.x += constantBufferData[n].velocity.x;
		if (constantBufferData[n].offset.x > offsetBounds)
		{
			constantBufferData[n].velocity.x = KazMath::FloatRand(0.01f, 0.02f);
			constantBufferData[n].offset.x = -offsetBounds;
		}
	}

	int num = RenderTargetStatus::Instance()->copySwapchain->GetCurrentBackBufferIndex();

	UINT8 *destination = static_cast<UINT8 *>(pointer) + (TRIANGLE_ARRAY_NUM * num * sizeof(SceneConstantBuffer));
	memcpy(destination, constantBufferData.data(), TRIANGLE_ARRAY_NUM * sizeof(SceneConstantBuffer));


	//蜈･蜉帷畑縺ｮ繝舌ャ繝輔ぃ險ｭ螳・
	{
		BufferMemorySize s = DescriptorHeapMgr::Instance()->GetSize(DESCRIPTORHEAP_MEMORY_SRV);
		DirectX12CmdList::Instance()->cmdList->SetComputeRootDescriptorTable(0, DescriptorHeapMgr::Instance()->GetGpuDescriptorView(s.startSize + (srvHandle - 1)));
	}

	//蜃ｺ蜉帷畑縺ｮ繝舌ャ繝輔ぃ險ｭ螳・
	{
		BufferMemorySize s = DescriptorHeapMgr::Instance()->GetSize(DESCRIPTORHEAP_MEMORY_TEXTURE_COMPUTEBUFFER);
		DirectX12CmdList::Instance()->cmdList->SetComputeRootDescriptorTable(1, DescriptorHeapMgr::Instance()->GetGpuDescriptorView(s.startSize + 1));
		DirectX12CmdList::Instance()->cmdList->SetComputeRootDescriptorTable(2, DescriptorHeapMgr::Instance()->GetGpuDescriptorView(s.startSize + 2));
		DirectX12CmdList::Instance()->cmdList->SetComputeRootDescriptorTable(3, DescriptorHeapMgr::Instance()->GetGpuDescriptorView(s.startSize + 3));
	}

	//蛟､遒ｺ隱・
	{
		//DirectX12CmdList::Instance()->cmdList->SetComputeRootDescriptorTable(4, DescriptorHeapMgr::Instance()->GetGpuDescriptorView(cbvSize.startSize + cbvHandle - 1));
	}
	DirectX12CmdList::Instance()->cmdList->SetComputeRootDescriptorTable(2, DescriptorHeapMgr::Instance()->GetGpuDescriptorView(size.startSize + 2));
	//ディスパッチ
	DirectX12CmdList::Instance()->cmdList->Dispatch(100, 10, 1);

	//繝ｫ繝ｼ繝亥ｮ壽焚
	//DirectX12CmdList::Instance()->cmdList->SetComputeRoot32BitConstants(1, 4, reinterpret_cast<void *>(&rootConst), 0);

	//蜈ｱ騾夂畑
	CommonData commonData;
	commonData.cameraMat = CameraMgr::Instance()->GetViewMatrix();
	commonData.projectionMat = CameraMgr::Instance()->GetPerspectiveMatProjection();
	commonData.increSize = sizeof(OutPutData);
	commonData.gpuAddress = buffer->GetGpuAddress(cbvMatHandle);
	buffer->TransData(commonHandle, &commonData, sizeof(CommonData));
	DirectX12CmdList::Instance()->cmdList->SetComputeRootConstantBufferView(4, buffer->GetGpuAddress(commonHandle));


	//繝・ぅ繧ｹ繝代ャ繝・
	DirectX12CmdList::Instance()->cmdList->Dispatch(1, 1, 1);
	//繧ｳ繝ｳ繝斐Η繝ｼ繝医す繧ｧ繝ｼ繝繝ｼ縺ｮ險育ｮ・------------------------

	//std::array<OutPutData, TRIANGLE_ARRAY_NUM> *result = static_cast<std::array<OutPutData, TRIANGLE_ARRAY_NUM> *>(buffer->GetMapAddres(outputMatHandle));

	{
//		void *dataMap = nullptr;
//		auto result = buffer->GetBufferData(cbvMatHandle)->Map(0, nullptr, (void **)&dataMap);
	//	if (SUCCEEDED(result))
//		{
			//memcpy(dataMap, buffer->GetMapAddres(outputMatHandle), TRIANGLE_ARRAY_NUM * sizeof(OutPutData));
			//buffer->GetBufferData(cbvMatHandle)->Unmap(0, nullptr);
	//	}
	}

	std::array<OutPutData, TRIANGLE_ARRAY_NUM> data;
	for (int i = 0; i < data.size(); ++i)
	{
		XMFLOAT3 pos = { 0.0f + i * 10.0f,10.0f,10.0f };
		XMFLOAT3 scale = { 15.0f,15.0f,15.0f };
		XMFLOAT3 rota = { 0.0f,0.0f,0.0f };

		XMMATRIX trans = KazMath::CaluTransMatrix(pos);
		XMMATRIX scaleM = KazMath::CaluScaleMatrix(scale);
		XMMATRIX rotaM = KazMath::CaluRotaMatrix(rota);

		XMMATRIX v = CameraMgr::Instance()->GetViewMatrix();
		XMMATRIX p = CameraMgr::Instance()->GetPerspectiveMatProjection();
		data[i].mat = (scaleM * rotaM * trans) * v * p;
		data[i].color = { 0.0f,0.0f,0.0f,1.0f };
	}

	buffer->TransData(cbvMatHandle, &data, TRIANGLE_ARRAY_NUM * sizeof(OutPutData));

}

void DebugScene::Draw()
{
	{
		//short commandBuffHandle = commandBufferHandle;
		short commandBuffHandle = drawCommandHandle;

		//謠冗判蜻ｽ莉､逋ｺ陦・------------------------
		int num = RenderTargetStatus::Instance()->copySwapchain->GetCurrentBackBufferIndex();
		RenderTargetStatus::Instance()->bbIndex = num;

		std::array<D3D12_RESOURCE_BARRIER, 2> barriers = {
		CD3DX12_RESOURCE_BARRIER::Transition(
			buffer->GetBufferData(commandBuffHandle).Get(),
			D3D12_RESOURCE_STATE_UNORDERED_ACCESS,
			D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT),
		CD3DX12_RESOURCE_BARRIER::Transition(
			RenderTargetStatus::Instance()->backBuffers[num].Get(),
			D3D12_RESOURCE_STATE_PRESENT,
			D3D12_RESOURCE_STATE_RENDER_TARGET)
		};
		DirectX12CmdList::Instance()->cmdList->ResourceBarrier(static_cast<unsigned int>(barriers.size()), barriers.data());



		//繧ｻ繝・ヨ-------------------------
		//繝ｬ繝ｳ繝繝ｼ繧ｿ繧ｲ繝・ヨ縺ｮ險ｭ螳・
		D3D12_CPU_DESCRIPTOR_HANDLE rtvH;
		rtvH = RenderTargetStatus::Instance()->rtvHeaps->GetCPUDescriptorHandleForHeapStart();
		rtvH.ptr += num * DirectX12Device::Instance()->dev->GetDescriptorHandleIncrementSize(RenderTargetStatus::Instance()->heapDesc.Type);
		DirectX12CmdList::Instance()->cmdList->OMSetRenderTargets(1, &rtvH, false, &RenderTargetStatus::Instance()->gDepth.dsvH[RenderTargetStatus::Instance()->handle]);


		RenderTargetStatus::Instance()->gDepth.Clear(RenderTargetStatus::Instance()->handle);
		RenderTargetStatus::Instance()->ClearDoubuleBuffer(BG_COLOR);
		//繧ｻ繝・ヨ-------------------------


		GraphicsPipeLineMgr::Instance()->SetPipeLineAndRootSignature(PIPELINE_NAME_GPUPARTICLE);

		DirectX12CmdList::Instance()->cmdList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
		DirectX12CmdList::Instance()->cmdList->IASetVertexBuffers(0, 1, &vertexBufferView);

		//PIXBeginEvent(DirectX12CmdList::Instance()->cmdList.Get(), 0, L"Cull invisible triangles");
		DirectX12CmdList::Instance()->cmdList->ExecuteIndirect
		(
			commandSig.Get(),
			TRIANGLE_ARRAY_NUM,
			buffer->GetBufferData(commandBuffHandle).Get(),
			0, //繝ｪ繧ｽ繝ｼ繧ｹ繝舌Μ繧｢縺ｮ蛻・ｊ譖ｿ縺医〒蛟､繧貞､峨∴繧句ｿ・ｦ√′縺ゅｋ縺九ｂ(offset縺悟・繧九→螳壽焚繝舌ャ繝輔ぃ縺ｮ蛟､縺・縺ｫ縺ｪ繧九・縺ｧ辟｡縺・
			nullptr,
			0
		);
		//PIXEndEvent(DirectX12CmdList::Instance()->cmdList.Get());

		barriers[0].Transition.StateBefore = D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT;
		barriers[0].Transition.StateAfter = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
		barriers[1].Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET;
		barriers[1].Transition.StateAfter = D3D12_RESOURCE_STATE_PRESENT;
		DirectX12CmdList::Instance()->cmdList->ResourceBarrier(static_cast<unsigned int>(barriers.size()), barriers.data());
		//謠冗判蜻ｽ莉､逋ｺ陦・------------------------
	}

	{
		RenderTargetStatus::Instance()->SetDoubleBufferFlame(BG_COLOR);
		bg.Draw();
		RenderTargetStatus::Instance()->SwapResourceBarrier();
	}

}

void DebugScene::Input()
{
	KeyBoradInputManager *input = KeyBoradInputManager::Instance();

#pragma region Camera
	debugCameraMove = { 0,0,0 };
	float debugSpeed = 1.0f;
	//・ｽJ・ｽ・ｽ・ｽ・ｽ・ｽﾚ難ｿｽ
	if (input->InputState(DIK_D))
	{
		debugCameraMove.x = -debugSpeed;
	}
	if (input->InputState(DIK_A))
	{
		debugCameraMove.x = debugSpeed;
	}
	if (input->InputState(DIK_W))
	{
		debugCameraMove.y = debugSpeed;
	}
	if (input->InputState(DIK_S))
	{
		debugCameraMove.y = -debugSpeed;
	}

	if (input->InputState(DIK_RIGHTARROW))
	{
		angle.x += debugSpeed;
	}
	if (input->InputState(DIK_LEFTARROW))
	{
		angle.x += -debugSpeed;
	}

	if (input->InputState(DIK_UPARROW))
	{
		angle.y += debugSpeed;
	}
	if (input->InputState(DIK_DOWNARROW))
	{
		angle.y += -debugSpeed;
	}
	eyePos = KazMath::CaluEyePosForDebug(eyePos, debugCameraMove, angle);
	targetPos = KazMath::CaluTargetPosForDebug(eyePos, angle.x);
	//eyePos.z = -5.0f;
#pragma endregion

}

int DebugScene::SceneChange()
{
	return -1;
}
